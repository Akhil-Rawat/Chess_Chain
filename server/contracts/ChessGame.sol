// SPDX-License-Identifier: MITpragma solidity ^0.8.17;/** * @title ChessGame - Enhanced Smart Contract * @dev Production-ready chess gaming contract with wagering * @author ChessChain Team */contract ChessGame {    // Game status enum    enum GameStatus { Waiting, InProgress, Completed, Cancelled }        // Game result enum      enum GameResult {         None, WhiteWins, BlackWins, Draw,        WhiteWinsByTime, BlackWinsByTime,        WhiteWinsByResignation, BlackWinsByResignation    }    // Game struct    struct Game {        uint256 id;        address whitePlayer;        address blackPlayer;        uint256 wagerAmount;        uint256 timeControl;        uint256 increment;        GameStatus status;        string fen;        bool whiteDrawOffered;        bool blackDrawOffered;        address currentTurn;        uint256 whiteTimeRemaining;        uint256 blackTimeRemaining;        uint256 lastMoveTime;        GameResult result;        address winner;        uint256 createdAt;        bool isRated;    }    // Player statistics    struct PlayerStats {        uint256 gamesPlayed;        uint256 gamesWon;        uint256 gamesLost;        uint256 gamesDrawn;        uint256 totalWagered;        uint256 totalWinnings;        uint256 rating;        bool isRegistered;    }    // State variables    uint256 private gameCounter;    uint256 public totalGamesCreated;    uint256 public totalValueLocked;    uint256 public platformFeesCollected;        // Constants    uint256 public constant INITIAL_RATING = 1200;    uint256 public constant MIN_WAGER = 0.001 ether;    uint256 public constant MAX_WAGER = 100 ether;    uint256 public constant PLATFORM_FEE_BASIS_POINTS = 250; // 2.5%        // Mappings    mapping(uint256 => Game) public games;    mapping(address => PlayerStats) public playerStats;    mapping(address => uint256[]) public playerGames;    mapping(uint256 => bool) public gameExists;        // Events    event GameCreated(uint256 indexed gameId, address indexed creator, uint256 wagerAmount);    event GameJoined(uint256 indexed gameId, address indexed whitePlayer, address indexed blackPlayer);    event MoveMade(uint256 indexed gameId, address indexed player, string move);    event GameCompleted(uint256 indexed gameId, GameResult result, address indexed winner, uint256 winnings);    event DrawOffered(uint256 indexed gameId, address indexed player);    event PlayerRegistered(address indexed player, uint256 initialRating);    // Modifiers    modifier gameExists_(uint256 gameId) {        require(gameExists[gameId], "Game does not exist");        _;    }        modifier onlyGamePlayer(uint256 gameId) {        Game memory game = games[gameId];        require(msg.sender == game.whitePlayer || msg.sender == game.blackPlayer, "Not a game player");        _;    }    constructor() {        gameCounter = 0;        totalGamesCreated = 0;        totalValueLocked = 0;        platformFeesCollected = 0;    }    /**     * @dev Register a new player     */    function registerPlayer() external {        require(!playerStats[msg.sender].isRegistered, "Already registered");                playerStats[msg.sender] = PlayerStats({            gamesPlayed: 0,            gamesWon: 0,            gamesLost: 0,            gamesDrawn: 0,            totalWagered: 0,            totalWinnings: 0,            rating: INITIAL_RATING,            isRegistered: true        });                emit PlayerRegistered(msg.sender, INITIAL_RATING);    }    /**     * @dev Create a new game     */    function createGame(uint256 timeControl, uint256 increment, bool isRated)         external payable     {        require(msg.value >= MIN_WAGER && msg.value <= MAX_WAGER, "Invalid wager");        require(timeControl >= 60 && timeControl <= 7200, "Invalid time control");                if (isRated) {            require(playerStats[msg.sender].isRegistered, "Must register for rated games");        }        gameCounter++;        uint256 gameId = gameCounter;                games[gameId] = Game({            id: gameId,            whitePlayer: block.timestamp % 2 == 0 ? msg.sender : address(0),            blackPlayer: block.timestamp % 2 == 1 ? msg.sender : address(0),            wagerAmount: msg.value,            timeControl: timeControl,            increment: increment,            status: GameStatus.Waiting,            fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",            whiteDrawOffered: false,            blackDrawOffered: false,            currentTurn: address(0),            whiteTimeRemaining: timeControl,            blackTimeRemaining: timeControl,            lastMoveTime: 0,            result: GameResult.None,            winner: address(0),            createdAt: block.timestamp,            isRated: isRated        });                gameExists[gameId] = true;        totalGamesCreated++;        totalValueLocked += msg.value;        playerGames[msg.sender].push(gameId);                emit GameCreated(gameId, msg.sender, msg.value);    }    /**     * @dev Join an existing game     */    function joinGame(uint256 gameId) external payable gameExists_(gameId) {        Game storage game = games[gameId];        require(game.status == GameStatus.Waiting, "Game not available");        require(msg.value == game.wagerAmount, "Incorrect wager amount");        require(msg.sender != game.whitePlayer && msg.sender != game.blackPlayer, "Cannot join own game");                if (game.isRated) {            require(playerStats[msg.sender].isRegistered, "Must register for rated games");        }                // Assign joiner to empty color        if (game.whitePlayer == address(0)) {            game.whitePlayer = msg.sender;        } else {            game.blackPlayer = msg.sender;        }                game.status = GameStatus.InProgress;        game.currentTurn = game.whitePlayer; // White starts        game.lastMoveTime = block.timestamp;                totalValueLocked += msg.value;        playerGames[msg.sender].push(gameId);                emit GameJoined(gameId, game.whitePlayer, game.blackPlayer);    }    /**     * @dev Make a move     */    function makeMove(uint256 gameId, string memory move, string memory newFen)         external gameExists_(gameId)     {        Game storage game = games[gameId];        require(game.status == GameStatus.InProgress, "Game not in progress");        require(game.currentTurn == msg.sender, "Not your turn");                // Calculate time spent        uint256 timeSpent = block.timestamp - game.lastMoveTime;                // Update time and switch turns        if (msg.sender == game.whitePlayer) {            if (timeSpent >= game.whiteTimeRemaining) {                _endGame(gameId, GameResult.BlackWinsByTime, game.blackPlayer);                return;            }            game.whiteTimeRemaining = game.whiteTimeRemaining - timeSpent + game.increment;            game.currentTurn = game.blackPlayer;        } else {            if (timeSpent >= game.blackTimeRemaining) {                _endGame(gameId, GameResult.WhiteWinsByTime, game.whitePlayer);                return;            }            game.blackTimeRemaining = game.blackTimeRemaining - timeSpent + game.increment;            game.currentTurn = game.whitePlayer;        }                game.fen = newFen;        game.lastMoveTime = block.timestamp;        game.whiteDrawOffered = false;        game.blackDrawOffered = false;                emit MoveMade(gameId, msg.sender, move);    }    /**     * @dev Resign from game     */    function resignGame(uint256 gameId) external gameExists_(gameId) onlyGamePlayer(gameId) {        Game storage game = games[gameId];        require(game.status == GameStatus.InProgress, "Game not in progress");                if (msg.sender == game.whitePlayer) {            _endGame(gameId, GameResult.BlackWinsByResignation, game.blackPlayer);        } else {            _endGame(gameId, GameResult.WhiteWinsByResignation, game.whitePlayer);        }    }    /**     * @dev Offer draw     */    function offerDraw(uint256 gameId) external gameExists_(gameId) onlyGamePlayer(gameId) {        Game storage game = games[gameId];        require(game.status == GameStatus.InProgress, "Game not in progress");                if (msg.sender == game.whitePlayer) {            game.whiteDrawOffered = true;        } else {            game.blackDrawOffered = true;        }                // Auto-accept if both offered        if (game.whiteDrawOffered && game.blackDrawOffered) {            _endGame(gameId, GameResult.Draw, address(0));        } else {            emit DrawOffered(gameId, msg.sender);        }    }    /**     * @dev Accept draw offer     */    function acceptDraw(uint256 gameId) external gameExists_(gameId) onlyGamePlayer(gameId) {        Game storage game = games[gameId];        require(game.status == GameStatus.InProgress, "Game not in progress");                bool drawOffered = false;        if (msg.sender == game.whitePlayer && game.blackDrawOffered) {            drawOffered = true;        } else if (msg.sender == game.blackPlayer && game.whiteDrawOffered) {            drawOffered = true;        }                require(drawOffered, "No draw offer from opponent");        _endGame(gameId, GameResult.Draw, address(0));    }    /**     * @dev Claim victory by time     */    function claimVictoryByTime(uint256 gameId) external gameExists_(gameId) onlyGamePlayer(gameId) {        Game storage game = games[gameId];        require(game.status == GameStatus.InProgress, "Game not in progress");                uint256 timeElapsed = block.timestamp - game.lastMoveTime;                if (game.currentTurn == game.whitePlayer) {            require(timeElapsed > game.whiteTimeRemaining + 300, "White still has time"); // 5 min buffer            _endGame(gameId, GameResult.BlackWinsByTime, game.blackPlayer);        } else {            require(timeElapsed > game.blackTimeRemaining + 300, "Black still has time");            _endGame(gameId, GameResult.WhiteWinsByTime, game.whitePlayer);        }    }    /**     * @dev End game and distribute funds     */    function _endGame(uint256 gameId, GameResult result, address winner) internal {        Game storage game = games[gameId];                game.status = GameStatus.Completed;        game.result = result;        game.winner = winner;                uint256 totalPot = game.wagerAmount * 2;        uint256 platformFee = (totalPot * PLATFORM_FEE_BASIS_POINTS) / 10000;        uint256 winnings = totalPot - platformFee;                totalValueLocked -= totalPot;        platformFeesCollected += platformFee;                // Update stats        _updatePlayerStats(game.whitePlayer, game.blackPlayer, result, game.wagerAmount);                // Distribute funds        if (winner != address(0)) {            playerStats[winner].totalWinnings += winnings;            payable(winner).transfer(winnings);            emit GameCompleted(gameId, result, winner, winnings);        } else {            // Draw - split winnings            uint256 halfWinnings = winnings / 2;            playerStats[game.whitePlayer].totalWinnings += halfWinnings;            playerStats[game.blackPlayer].totalWinnings += halfWinnings;            payable(game.whitePlayer).transfer(halfWinnings);            payable(game.blackPlayer).transfer(halfWinnings);            emit GameCompleted(gameId, result, address(0), winnings);        }    }    /**     * @dev Update player statistics     */    function _updatePlayerStats(address whitePlayer, address blackPlayer, GameResult result, uint256 wagerAmount) internal {        playerStats[whitePlayer].gamesPlayed++;        playerStats[blackPlayer].gamesPlayed++;        playerStats[whitePlayer].totalWagered += wagerAmount;        playerStats[blackPlayer].totalWagered += wagerAmount;                if (result == GameResult.WhiteWins || result == GameResult.WhiteWinsByTime || result == GameResult.WhiteWinsByResignation) {            playerStats[whitePlayer].gamesWon++;            playerStats[blackPlayer].gamesLost++;        } else if (result == GameResult.BlackWins || result == GameResult.BlackWinsByTime || result == GameResult.BlackWinsByResignation) {            playerStats[blackPlayer].gamesWon++;            playerStats[whitePlayer].gamesLost++;        } else if (result == GameResult.Draw) {            playerStats[whitePlayer].gamesDrawn++;            playerStats[blackPlayer].gamesDrawn++;        }    }    // View functions    function getGame(uint256 gameId) external view returns (Game memory) {        return games[gameId];    }        function getPlayerStats(address player) external view returns (PlayerStats memory) {        return playerStats[player];    }        function getPlayerGames(address player) external view returns (uint256[] memory) {        return playerGames[player];    }        function getActiveGames() external view returns (uint256[] memory) {        uint256[] memory activeGames = new uint256[](gameCounter);        uint256 count = 0;                for (uint256 i = 1; i <= gameCounter; i++) {            if (games[i].status == GameStatus.Waiting || games[i].status == GameStatus.InProgress) {                activeGames[count] = i;                count++;            }        }                // Resize array        uint256[] memory result = new uint256[](count);        for (uint256 i = 0; i < count; i++) {            result[i] = activeGames[i];        }                return result;    }}